1. bus-extensions.txt: ToolBox extension seems to be obsolate? 
   Doesn't exist in packages
2. Was fault scenario tested? There are no outFault interceptors initialized
3. Role of ActionVerifierInterceptor is not clear.
   As far as I see it just checks that wsa:action is non-empty.
   But by default, if wsa feature is active, CXF sets WSA action.
   Is it not enough to verify that on reciever side?
4. CallbackActionInterceptor:
   a) What is the reason to explicitly set soapAction into SoapOperationIOnfo?
      Is it workaround for SOAPAction mismatch error?
      Take into account that since CXF 2.7.11 you can match empty SoapOperationInfo action
      to non-empty SOAPAction by activating allowNonMatchingToDefaultSoapAction property.
      Perhaps it is more elegant way.
   b) Do not get logic in handleAddressing():
      // disable CXF decoupled response
      exchange.setOneWay(false);
      CXF decoupled responses are allowed only for request-response, not oneWay.
5. RequestCallbackOutInterceptor
   a) Do not understand logic with ActionVerifierInterceptor.ACTION_VERIFICATION_PROPERTY_NAME:
		if (action == null || StringUtils.isEmpty(action.getValue())) {
			message.put(ActionVerifierInterceptor.ACTION_VERIFICATION_PROPERTY_NAME,
					Boolean.TRUE);
		}
      The action will be additionaly validated into ActionVerifierInterceptor, but who will set it?
6. ConfigurationUpdater & Activator:
   Is not easy to use blueprint for OSGi to set and update the properties?
   Blueprint handles updates automatically.

7. RequestCallbackTest:
   Why it is necessary to parse WSDL in test?
   I think port should be created from the WSDL here, it is not necessary to do it manually:
        final Service service = Service.create(
        		getClass().getResource(wsdlLocation), SERVICE_NAME);
        service.addPort(PORT_NAME, endpointInfo.getBinding().getBindingId(),
        		endpointInfo.getAddress());


8. SeekBookInBasementHandler:
   I think we should hide this code from business implementation, it is too technical:

         if (context.getReplyToAddress().startsWith("jms")) {
            JmsConfigurator cConfigurator = JmsConfigurator.create(responseProxy);
            cConfigurator.configureDispatch(responseProxy);
        }

   Why this cannot be done in CallContext?
   Basically the JMS Configuration in CXF 3.0.0 style is just one URL. I think we should use that.
